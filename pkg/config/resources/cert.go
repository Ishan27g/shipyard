package resources

import "github.com/shipyard-run/hclconfig/types"

// TypeCertificateCA is the resource string for a self-signed CA
const TypeCertificateCA string = "certificate_ca"

// CertificateCA allows the generate of CA certificates
type CertificateCA struct {
	types.ResourceMetadata `hcl:",remain"`

	// Output directory to write the certificate and key too
	Output string `hcl:"output" json:"output"`

	// output parameters

	// KeyPath is the absolute file path to the key generated by the resource
	KeyPath string `hcl:"key_path" json:"key_path"`

	// CertPath is the absolute file path to the certificate generated by the resource
	CertPath string `hcl:"cert_path" json:"cert_path"`
}

func (c *CertificateCA) Process() error {
	c.Output = ensureAbsolute(c.Output, c.File)

	// do we have an existing resource in the state?
	// if so we need to set any computed resources for dependents
	cfg, err := LoadState()
	if err == nil {
		// try and find the resource in the state
		r, _ := cfg.FindResource(c.ID)
		if r != nil {
			kstate := r.(*CertificateCA)
			c.KeyPath = kstate.KeyPath
			c.CertPath = kstate.CertPath
		}
	}

	return nil
}

// TypeCertificateCA is the resource string for a self-signed CA
const TypeCertificateLeaf string = "certificate_leaf"

// CertificateCA allows the generate of CA certificates
type CertificateLeaf struct {
	types.ResourceMetadata `hcl:",remain"`

	CAKey  string `hcl:"ca_key" json:"ca_key"`   // Path to the primary key for the root CA
	CACert string `hcl:"ca_cert" json:"ca_cert"` // Path to the root CA

	IPAddresses []string `hcl:"ip_addresses,optional" json:"ip_addresses,omitempty"` // ip addresses to add to the cert
	DNSNames    []string `hcl:"dns_names,optional" json:"dns_names,omitempty"`       // DNS names to add to the cert

	Output string `hcl:"output" json:"output"` // output location for the certificate

	// output parameters

	// KeyPath is the absolute file path to the key generated by the resource
	KeyPath string `hcl:"key_path" json:"key_path"`

	// CertPath is the absolute file path to the certificate generated by the resource
	CertPath string `hcl:"cert_path" json:"cert_path"`
}

func (c *CertificateLeaf) Process() error {
	c.CACert = ensureAbsolute(c.CACert, c.File)
	c.CAKey = ensureAbsolute(c.CAKey, c.File)
	c.Output = ensureAbsolute(c.Output, c.File)

	// do we have an existing resource in the state?
	// if so we need to set any computed resources for dependents
	cfg, err := LoadState()
	if err == nil {
		// try and find the resource in the state
		r, _ := cfg.FindResource(c.ID)
		if r != nil {
			kstate := r.(*CertificateLeaf)
			c.KeyPath = kstate.KeyPath
			c.CertPath = kstate.CertPath
		}
	}

	return nil
}
